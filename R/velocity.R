#' Add velocity to a dynwrap dataset
#'
#' @inheritParams dynwrap::add_trajectory
#' @inheritParams get_velocity
#' @param velocity The velocity object as generated by [get_velocity()].
#'
#' @importFrom dynutils add_class
#'
#' @export
add_velocity <- function(
  dataset,
  spliced = dataset$expression,
  unspliced = dataset$expression_unspliced,
  mode = c("stochastic", "deterministic", "dynamical"),
  n_neighbors = 20L,
  velocity = get_velocity(spliced = spliced, unspliced = unspliced, mode = mode, n_neighbors = n_neighbors)
) {
  mode <- match.arg(mode)
  assert_that(!is.null(velocity$velocity))

  dataset$velocity_vector <- velocity$velocity_vector
  velocity$velocity_vector <- NULL
  dataset$velocity <- velocity

  dynutils::add_class(dataset, "wrapper_with_velocity")

  dataset
}


#' Calculate velocity
#'
#' @param spliced Spliced expression matrix
#' @param unspliced Unspliced expression matrix
#' @param var_names Names of variables/genes to use for the fitting. Can be `"velocity_genes"`, `"all"`, or a set of gene names.
#' @param n_neighbors Number of neighbors to use.
#'
#' @importFrom methods as
#'
#' @export
get_velocity <- function(
  spliced,
  unspliced,
  mode = c("stochastic", "deterministic", "dynamical", "dynamical_residuals"),
  n_neighbors = 20L,
  var_names = "velocity_genes"
) {
  # check inputs
  mode <- match.arg(mode)
  assert_that(
    all(dim(spliced) == dim(unspliced)),
    all(rownames(spliced) == rownames(unspliced)),
    all(colnames(spliced) == colnames(unspliced))
  )

  # let scvelo do its own normalisation
  spliced <- as(2^spliced-1, "dgCMatrix")
  unspliced <- as(2^unspliced-1, "dgCMatrix")

  # create anndata object
  adata <- anndata$AnnData(spliced)
  adata$var_names <- colnames(spliced)
  adata$obs_names <- rownames(spliced)

  py_assign(adata$layers, "spliced", spliced)
  py_assign(adata$layers, "unspliced", unspliced)

  scvelo$pp$filter_and_normalize(adata)
  scvelo$pp$moments(adata, n_neighbors = n_neighbors)

  if (mode %in% c("dynamical", "dynamical_residuals")) {
    scvelo$tl$recover_dynamics(adata, var_names = var_names)
  }
  scvelo$tl$velocity(adata, mode = mode)
  scvelo$tl$velocity_graph(adata)

  velocity_vector <- adata$layers[["velocity"]]
  velocity_vector[is.na(velocity_vector)] <- 0

  dimnames(velocity_vector) <- dimnames(spliced)

  velocity_vector <- as(velocity_vector, "dgCMatrix")

  # get transition matrix
  py$x <- adata
  py_run_string("import scvelo")
  transition_matrix <- py_to_r(py_eval("scvelo.tl.transition_matrix(x).tocsc()"))
  colnames(transition_matrix) <- rownames(spliced)
  rownames(transition_matrix) <- rownames(spliced)

  # return velocity object
  list(
    velocity_vector = velocity_vector,
    transition_matrix = transition_matrix,
    scvelo = velocity
  )
}

# Checks if the scvelo object is still present
# this is not the case after saving the R object as an rds
check_scvelo <- function(scvelo) {
  if(is.null(scvelo)) {
    FALSE
  } else if(as.character(scvelo) == "<pointer: 0x0>") {
    FALSE
  } else {
    TRUE
  }
}
